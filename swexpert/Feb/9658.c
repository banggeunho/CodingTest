// # 9658 유효숫자 표기 문제

// 주어진 정수의 앞 두 자리를 유효숫자로 하여 표기하는 프로그램을 작성하세요.
 
// 예를 들어 정수 588235는 5.88235*105 인데, 앞의 소수 부분을 소수점 두 번째 자리에서 반올림하여 5.9*105로 나타내는 것입니다.
 
// 하나의 예외로, 9999 같은 경우 9.999*103에서 9.999의 소수점 두 번째 자리를 반올림하여 1.0*104으로 나타내야 합니다.


// [입력]
 
// 첫 번째 줄에 테스트 케이스의 수 TC가 주어진다
// 이후 TC개의 테스트 케이스가 새 줄로 구분되어 주어진다.
// 각 테스트 케이스마다 하나의 정수 N이 주어진다. ( 102 ≤ N ≤ 10100000)


// [출력]

// 각 테스트 케이스마다 ‘# ’( t 는 테스트케이스 번호를 의미하며 1부터 시작한다)를 출력하고,
// 주어진 정수의 앞 두 자리를 유효숫자로 하여 출력한다. 출력 예제의 형식을 따라 출력해야 한다.


// 문제 해결 포인트 : 입력 받는 정수의 크기는 엄청크다 따라서, 연산으로 푸는 것은 불가능 -> 시간초과 발생
// 따라서, 입력 받은 숫자를 스트링으로 간주하여 반올림이 생기는 현상에 대해 스트링으로 처리하기

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>

int main(void)
{
	int test_case;
	int T;

	setbuf(stdout, NULL);
	scanf("%d\n", &T);
	/*
	여러 개의 테스트 케이스를 처리하기 위한 부분입니다.
	*/
	for (test_case = 1; test_case <= T; ++test_case)
	{
        char n[100000];
        int exp;
        float result;

		    scanf("%s", n);
        exp = strlen(n)-1;

        // 999와 같은 예외 경우 (반올림 시 전체 길이가 1 늘어남)
        if (n[0] == '9' && n[1] == '9')
        {
          if( n[2] - '0' >= 5)
          {
            n[0] = '1';
            n[1] = '0';
            exp ++;
          }
        }
        // 예외 경우가 아닌경우 반올림 처리
        // 456 -> 4.56 -> 4.6
        else {
          // 반올림 하는 경우
          if (n[2] -'0' >= 5)
          {
            if(n[1] == '9')
            {
            n[0] += 1;
            n[1] = '0';
            }
            else
            {
            n[1] = n[1] + 1;
            n[2] = '0';
            }
          }
          // 반올림 안할경우
        }
	      printf("#%d %c.%c*%d^%d\n", test_case, n[0], n[1], 10, exp);
	}
	return 0; //정상종료시 반드시 0을 리턴해야 합니다.
}



